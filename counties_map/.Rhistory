pacf(data, lag.max = 72, plot = TRUE, xlab = "time lag", ylab = "Sample PACF", ylim = c(-0.5,1), main = "")
acf(data2, lag.max = 72, type = "correlation", plot = TRUE, xlab = "time lag", ylab = "Sample ACF", ylim = c(-0.5,1), main = "")
acf(data2, lag.max = 72, type = "correlation", plot = TRUE, xlab = "time lag", ylab = "Sample ACF", ylim = c(-0.5,1), main = "")
pacf(data2, lag.max = 72, type = "correlation", plot = TRUE, xlab = "time lag", ylab = "Sample ACF", ylim = c(-0.5,1), main = "")
pacf(data2, lag.max = 72, plot = TRUE, xlab = "time lag", ylab = "Sample ACF", ylim = c(-0.5,1), main = "")
pacf(data2, lag.max = 72, plot = TRUE, xlab = "time lag", ylab = "Sample PACF of Residuals", ylim = c(-0.5,1), main = "")
plot(t, data, pch = 20, cex = 1.5, col = "blue")
lines(t, data, pch = 20, cex = 1.5, col = "blue")
title("Data")
iid.test(data2)
??iid.test
library(tidyverse)
library(tseries)
data = read.table('C:/Users/80921/OneDrive/桌面/course/5221 Time Series Analysis/data/deaths.txt')
data = c(data)$V1
t = 1:length(data)
bds.test(data2)
x <- rnorm(100)
bds.test(x)
data2
x <- c(rnorm(50), runif(50))
bds.test(x)
x <- quadmap(xi = 0.2, a = 4.0, n = 100)
bds.test(x)
bds.test(data)
bds.test(data2, m = 10)
quadmap(xi = 0.2, a = 4.0, n = 100)
?bds.test
x <- rnorm(100)
bds.test(x)
x <- rnorm(100, 20,1)
bds.test(x)
x <- c(rnorm(50, 50,1), runif(50))
bds.test(x)
x <- c(rnorm(50), runif(50))
bds.test(x)
x <- c(rnorm(50, 10000,1), runif(50))
bds.test(x)
x <- quadmap(xi = 0.2, a = 4.0, n = 100)
bds.test(x)
x <- quadmap(xi = 0.2, a = 4.0, n = 1000)
bds.test(x)
data2
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tseries)
data = read.table('C:/Users/80921/OneDrive/桌面/course/5221 Time Series Analysis/data/deaths.txt')
data = c(data)$V1
t = 1:length(data)
plot(t, data, pch = 20, cex = 1.5, col = "blue",
xlab = 'Time lag', ylab = 'Value')
lines(t, data, pch = 20, cex = 1.5, col = "blue")
title("Data")
plot(t, data, pch = 20, cex = 1.5, col = "blue",
xlab = 'Time lag', ylab = 'Value')
lines(t, data, pch = 20, cex = 1.5, col = "blue")
title("Data")
acf(data, lag.max = 72, type = "correlation",
plot = TRUE, xlab = "Time lag", ylab = "Sample ACF",
ylim = c(-0.5,1), main = "")
pacf(data, lag.max = 72, plot = TRUE,
xlab = "time lag", ylab = "Sample PACF",
ylim = c(-0.5,1), main = "")
lambda.1 = 2*pi/12
lambda.2 = 2*pi/6
lambda.3 = 2*pi/3
cos.1 = cos(lambda.1*t)
sin.1 = sin(lambda.1*t)
cos.2 = cos(lambda.2*t)
sin.2 = sin(lambda.2*t)
cos.3 = cos(lambda.3*t)
sin.3 = sin(lambda.3*t)
t2 = t^2
model1 = lm(data ~ 1 + cos.1 + sin.1 + cos.2 + sin.2 + t + t2)
summary(model1)
data2 = data - model1$coefficients[1] -
model1$coefficients[2]*cos.1 - model1$coefficients[3]*sin.1 -
model1$coefficients[4]*cos.2 - model1$coefficients[5]*sin.2 -
model1$coefficients[8]*t - model1$coefficients[9]*t^2
plot(t, data2, pch = 20, cex = 1.5, col = "blue",
xlab = 'Time lag', ylab = 'Value')
data2
lambda.1 = 2*pi/12
lambda.2 = 2*pi/6
lambda.3 = 2*pi/3
cos.1 = cos(lambda.1*t)
sin.1 = sin(lambda.1*t)
cos.2 = cos(lambda.2*t)
sin.2 = sin(lambda.2*t)
cos.3 = cos(lambda.3*t)
sin.3 = sin(lambda.3*t)
t2 = t^2
model1 = lm(data ~ 1 + cos.1 + sin.1 + cos.2 + sin.2 + cos.3 + sin.3 + t + t2)
summary(model1)
data2 = data - model1$coefficients[1] -
model1$coefficients[2]*cos.1 - model1$coefficients[3]*sin.1 -
model1$coefficients[4]*cos.2 - model1$coefficients[5]*sin.2 -
model1$coefficients[6]*cos.3 - model1$coefficients[7]*sin.3 -
model1$coefficients[8]*t - model1$coefficients[9]*t^2
plot(t, data2, pch = 20, cex = 1.5, col = "blue",
xlab = 'Time lag', ylab = 'Value')
lines(t, data2, pch = 20, cex = 1.5, col = "blue")
title("Residuals")
acf(data2, lag.max = 72, type = "correlation", plot = TRUE, xlab = "time lag", ylab = "Sample ACF of Residuals", ylim = c(-0.5,1), main = "")
pacf(data2, lag.max = 72, plot = TRUE, xlab = "time lag", ylab = "Sample PACF of Residuals", ylim = c(-0.5,1), main = "")
bds.test(data2)
acf(data2, lag.max = 72, type = "correlation", plot = TRUE, xlab = "time lag", ylab = "Sample ACF of Residuals", ylim = c(-1,1), main = "")
lambda.1 = 2*pi/12
lambda.2 = 2*pi/6
cos.1 = cos(lambda.1*t)
sin.1 = sin(lambda.1*t)
cos.2 = cos(lambda.2*t)
sin.2 = sin(lambda.2*t)
t2 = t^2
model1 = lm(data ~ 1 + cos.1 + sin.1 + cos.2 + sin.2 + t + t2)
summary(model1)
data2 = data - model1$coefficients[1] -
model1$coefficients[2]*cos.1 - model1$coefficients[3]*sin.1 -
model1$coefficients[4]*cos.2 - model1$coefficients[5]*sin.2 -
model1$coefficients[6]*t - model1$coefficients[7]*t^2
plot(t, data2, pch = 20, cex = 1.5, col = "blue",
xlab = 'Time lag', ylab = 'Value')
lines(t, data2, pch = 20, cex = 1.5, col = "blue")
title("Residuals")
acf(data2, lag.max = 72, type = "correlation", plot = TRUE, xlab = "time lag", ylab = "Sample ACF of Residuals", ylim = c(-0.5,1), main = "")
pacf(data2, lag.max = 72, plot = TRUE, xlab = "time lag", ylab = "Sample PACF of Residuals", ylim = c(-0.5,1), main = "")
bds.test(data2)
shiny::runApp('C:/Users/80921/OneDrive/桌面/course/5243 Applied Data Science/Project/Spring2020-Project2-group7/app')
runApp('C:/Users/80921/OneDrive/桌面/course/5243 Applied Data Science/Project/Spring2020-Project2-group7/app')
runApp('C:/Users/80921/OneDrive/桌面/course/5243 Applied Data Science/Project/Spring2020-Project2-group7/counties_map')
### all images corresponding to digit "3"
zip.3 <- read.table("zip3.txt", header=FALSE, sep=",")
zip.3 <- as.matrix(zip.3)
### all images corresponding to digit "5"
zip.5 <- read.table("zip5.txt", header=FALSE, sep=",")
zip.5 <- as.matrix(zip.5)
### n.3 and n.5 are the total number of "3"s and "5"s, respectively.
n.3 <- length(zip.3[,1])
n.5 <- length(zip.5[,1])
### combine two data sets together
X.full.zip <-rbind(zip.3,zip.5)
dim(X.full.zip)
### define response (labels)
Y.full.zip <- c(rep("Three",n.3),rep("Five",n.5))
length(Y.full.zip)
output.image<-function(vector) {
digit<-matrix(vector, nrow=16, ncol=16)
#index= seq(from=1, to =16, by=1)
index= seq(from=16, to =1, by=-1)
sym_digit = digit[,index]
image(sym_digit, col= gray((8:0)/8), axes=FALSE)
}
par(mfrow=c(5,5),mai=c(0.1,0.1,0.1,0.1))
for(i in 1:25) {
output.image(zip.3[i,])
}
par(mfrow=c(5,5),mai=c(0.1,0.1,0.1,0.1))
for(i in 1:25) {
output.image(zip.5[i,])
}
## Solution goes here ---------
set.seed(26)
n = nrow(X.full.zip)
ratio = 0.8
order = sample(1:n,n)
training.set = order[1:ceiling(n*0.8)]
training.value = X.full.zip[training.set,]
training.label = Y.full.zip[training.set]
test.set = order[(ceiling(n*0.8)+1):n]
test.value = X.full.zip[test.set,]
test.label = Y.full.zip[test.set]
# Create basic training data from iris
X.example <- as.matrix(iris[51:150,1:2])
Y.example <- as.character(iris[51:150,5])
head(X.example,3)
head(Y.example,3)
# kNN function
KNN.decision <- function(x.test,
X.data,
Y.data,
K = 5) {
#n <- nrow(X.data)
dists.vec <- sqrt((x.test[1]- X.data[,1])^2 + (x.test[2]-X.data[,2])^2)
neighbors  <- order(dists.vec)[1:K]
neighb.dir <-  Y.data[neighbors]
choice     <- names(which.max(table(neighb.dir)))
return(choice)
}
# Evaluate kNN.decision() at x.test.1:
x.test.1 <- c(5.5,3.0)
p1.choice <- KNN.decision(x.test=x.test.1,
X.data=X.example,
Y.data=Y.example,
K=5)
p1.choice
# Evaluate kNN.decision() at x.test.2:
x.test.2 <- c(7.5,3)
p2.choice <- KNN.decision(x.test=x.test.2,
X.data=X.example,
Y.data=Y.example,
K=5)
p2.choice
# Plot X2 versus X1 with the test points
plot(X.example[,1],
X.example[,2],
xlab="X1",
ylab="X2",
col=factor(Y.example))
col1 <- ifelse(p1.choice=="versicolor",1,2)
points(x.test.1[1],x.test.1[2],pch="*",cex=3,col=col1)
text(x.test.1[1],x.test.1[2]+.1,labels=p1.choice,cex=.6,col=col1)
col2 <- ifelse(p2.choice=="versicolor",1,2)
points(x.test.2[1],x.test.2[2],pch="*",cex=3,col=col2)
text(x.test.2[1],x.test.2[2]+.1,labels=p2.choice,cex=.6,col=col2)
legend("topleft",legend=levels(factor(Y.example)),
fill=1:2,cex=.75)
## Solution goes here ---------
# kNN function
KNN.decision2 <- function(x.test,
X.data,
Y.data,
K = 5) {
dists.vec <- apply(X.data, 1, function(x) sqrt(sum((x-x.test)^2)))
neighbors  <- order(dists.vec)[1:K]
neighb.dir <-  Y.data[neighbors]
choice     <- names(which.max(table(neighb.dir)))
return(choice)
}
## Solution goes here ---------
result = apply(test.value, 1, function(x) KNN.decision2(x, training.value, training.label))
print(paste0('The test error is:', 1-mean(result == test.label)))
result = apply(training.value, 1, function(x) KNN.decision2(x, training.value, training.label))
print(paste0('The test error is:', 1-mean(result == training.label)))
## Solution goes here ---------
num = c(1,3,5,7,9,11)
test.err = NULL
training.err = NULL
for (i in 1:length(num)){
test.result = apply(test.value, 1,
function(x) KNN.decision2(x, training.value,
training.label,
K = num[i]))
test.err[i] = 1 - mean(test.result == test.label)
training.result = apply(training.value, 1,
function(x) KNN.decision2(x, training.value,
training.label,
K = num[i]))
training.err[i] = 1 - mean(training.result == training.label)
}
plot(num, test.err, pch = 20, cex = 1.5 ,col = "red", xlab = 'K', ylab = 'Error rate')
lines(num, test.err, pch = 20, cex = 1.5 ,col = "red")
points(num, training.err, pch = 20, cex = 1.5 ,col = "blue", )
lines(num, training.err, pch = 20, cex = 1.5 ,col = "blue")
title('Training and Test Error')
legend("topright", legend=c('Test', 'Training'), fill = c('red', 'blue'), cex = .8)
plot(num, test.err, pch = 20, cex = 1.5 ,col = "red", xlab = 'K', ylab = 'Error rate', xlim = c(0,0.04))
lines(num, test.err, pch = 20, cex = 1.5 ,col = "red")
points(num, training.err, pch = 20, cex = 1.5 ,col = "blue", )
lines(num, training.err, pch = 20, cex = 1.5 ,col = "blue")
title('Training and Test Error')
legend("topright", legend=c('Test', 'Training'), fill = c('red', 'blue'), cex = .8)
plot(num, test.err, pch = 20, cex = 1.5 ,col = "red", xlab = 'K', ylab = 'Error rate', ylim = c(0,0.04))
lines(num, test.err, pch = 20, cex = 1.5 ,col = "red")
points(num, training.err, pch = 20, cex = 1.5 ,col = "blue", )
lines(num, training.err, pch = 20, cex = 1.5 ,col = "blue")
title('Training and Test Error')
legend("topright", legend=c('Test', 'Training'), fill = c('red', 'blue'), cex = .8)
x = runif(200,0,1)
x
mx = mean(x)
sum((x-mx)^2)*2
sum(x^2)*(1-1/200)
sx = sum(x)
sx
mx
n = 200
sum(x^2)+1/200*(sx^2)-2/n*sx*sx
sum(x^2)-2/n*sx*sx
?lda
??lda
require("ggplot2")
require("reshape2")
data(cora.documents)
data(cora.vocab)
theme_set(theme_bw())
set.seed(8675309)
K <- 10 ## Num clusters
result <- lda.collapsed.gibbs.sampler(cora.documents,
K,  ## Num clusters
cora.vocab,
25,  ## Num iterations
0.1,
0.1,
compute.log.likelihood=TRUE)
## Get the top words in the cluster
top.words <- top.topic.words(result$topics, 5, by.score=TRUE)
## Number of documents to display
N <- 10
topic.proportions <- t(result$document_sums) / colSums(result$document_sums)
topic.proportions <-
topic.proportions[sample(1:dim(topic.proportions)[1], N),]
topic.proportions[is.na(topic.proportions)] <-  1 / K
colnames(topic.proportions) <- apply(top.words, 2, paste, collapse=" ")
topic.proportions.df <- melt(cbind(data.frame(topic.proportions),
document=factor(1:N)),
variable.name="topic",
id.vars = "document")
qplot(topic, value, fill=document, ylab="proportion",
data=topic.proportions.df, geom="bar", stat="identity") +
theme(axis.text.x = element_text(angle=90, hjust=1)) +
coord_flip() +
facet_wrap(~ document, ncol=5)
library(kknn)
data("miete")
head(miete)
dim(miete)
summary(miete)
install.packages('kknn')
library(kknn)
data("miete")
head(miete)
dim(miete)
summary(miete)
install.packages('sampling')
library(sampling)
n=round(2/3*nrow(miete)/5)
n
sub_train=strata(miete,stratanames="nmkat",size=rep(n,5),method="srswor")
head(sub_train)
#剔除1、3、12 属性
data_train=getdata(miete[,c(-1,-3,-12)],sub_train$ID_unit)
data_test=getdata(miete[,c(-1,-3,-12)],-sub_train$ID_unit)
dim(data_test);dim(data_train)
library(MASS)
ff1=lda(nmkat~.,data_train)
head(ff1)
ff1$prior
ff1$counts
ff1$means
ff1
ff2=predict(ff1,data_test)
ff2$class
ff2$posterior
table(data_test$nmkat,ff2$class)
### all images corresponding to digit "3"
zip.3<-read.table("zip3.txt", header=FALSE, sep=",")
### all images corresponding to digit "3"
zip.3<-read.table("zip3.txt", header=FALSE, sep=",")
zip.3<-as.matrix(zip.3)
### all images corresponding to digit "5"
zip.5<-read.table("zip5.txt", header=FALSE, sep=",")
zip.5<-as.matrix(zip.5)
### n.3 and n.5 are the total number of "3"s and "5"s, respectively.
n.3<-length(zip.3[,1])
n.5<-length(zip.5[,1])
### combine two data sets together
data<-rbind(zip.3, zip.5)
output.image<-function(vector) {
digit<-matrix(vector, nrow=16, ncol=16)
#index= seq(from=1, to =16, by=1)
index= seq(from=16, to =1, by=-1)
sym_digit = digit[,index]
image(sym_digit, col= gray((8:0)/8), axes=FALSE)
}
par(mfrow=c(10,10),mai=c(0.1,0.1,0.1,0.1))
for(i in 1:100) {
output.image(zip.3[i,])
}
par(mfrow=c(1,1),mai=c(0.6,0.6,0.6,0.6))
mean.3<- apply(zip.3, 2, mean)
### visualize the mean ###
output.image(mean.3)
scaled.3 <- scale(zip.3,center=TRUE, scale=FALSE)
pca <- svd(scaled.3)
par(mfrow=c(4,4), mai=c(0.1,0.1, 0.1, 0.1))
for(j in 1:16) {
output.image(pca$v[,j])
}
scaled.3
?scale
x <- matrix(1:10, ncol = 2)
(centered.x <- scale(x, scale = FALSE))
x
scale(x, scale = FALSE)
cov(centered.scaled.x <- scale(x))
scale(x)
x
centered.x
a = scale(x)
a
a[1]
c(a)
cov(a)
a[1]
a[2]
a[1]^2+a[2]^2
a^2
a
cov(a)
?cov
cor(a)
pca <- svd(scaled.3)
par(mfrow=c(4,4), mai=c(0.1,0.1, 0.1, 0.1))
for(j in 1:16) {
output.image(pca$v[,j])
}
svd(scaled.3)
pca$v
pca$v[,1]
scaled.data<-scale(data, center=TRUE, scale=FALSE)
pca <- svd(scaled.data)
par(mfrow=c(1,1), mai=c(0.6, 0.6, 0.6, 0.6))
plot(pca$d[1]* pca$u[,1], pca$d[2]* pca$u[, 2],pch=16, xlab="First Principle Component", ylab="Second Principle Component" )
scale(data, center=TRUE, scale=FALSE)
data
pac$d
pca$d
plot(pca$d[1]*pca$u[1:n.3, 1], pca$d[2]*pca$u[1:n.3, 2], pch="3", col="red", cex=0.8,xlim=c(-10, 10), ylim=c(-10, 10), xlab="First Principle Component", ylab="Second Principle Component")
points(pca$d[1]*pca$u[(n.3+1):(n.3+n.5), 1], pca$d[2]* pca$u[(n.3+1):(n.3+n.5), 2], cex=0.8,pch="5", col="blue")
plot(seq(from=1,to=256, by=1), (pca$d)^2/sum((pca$d)^2), xlab="Priciple componnets", ylab="Proportion of variance explained", pch=16)
km.out<- kmeans(data, 2, nstart=50)
km.out<- kmeans(data, 2, nstart=50)
### Visualize the centroids of each cluster ###
digit_centers<-km.out$centers
par(mfrow=c(1,2), mai=c(0.1,0.1,0.1,0.1))
for(i in 1:2) {
output.image(digit_centers[i,])
}
km.out
km.out$centers
plot(pca$d[1]*pca$u[, 1], pca$d[2]*pca$u[, 2],
col=km.out$cluster,
cex=0.8,
xlim=c(-10, 10),
ylim=c(-10, 10),
xlab="First Principle Component", ylab="Second Principle Component",
main="K-means Assignments"
)
km.out$cluster
knitr::opts_chunk$set(echo = TRUE)
train.3 = read.txt("train_3.txt")
??read.txt
library(tidyverse)
train.3 = read.txt("train_3.txt")
library(tidyverse)
train.3 = read.table("train_3.txt")
library(tidyverse)
train.3 = read.table("train_3.txt")
train.5 = read.table("train_5.txt")
train.8 = read.table("train_8.txt")
text = read.table("zip_test")
library(tidyverse)
train.3 = read.table("train_3.txt")
train.5 = read.table("train_5.txt")
train.8 = read.table("train_8.txt")
text = read.table("zip_test.txt")
train.3
head(train.3)
?read.txt
?read.table
library(tidyverse)
train.3 = read.table("train_3.txt", sep = ",")
train.5 = read.table("train_5.txt", sep = ",")
train.8 = read.table("train_8.txt", sep = ",")
text = read.table("zip_test.txt", sep = ",")
clc
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
train.3 = read.table("train_3.txt", sep = ",")
train.5 = read.table("train_5.txt", sep = ",")
train.8 = read.table("train_8.txt", sep = ",")
text = read.table("zip_test.txt", sep = ",")
load("../output/Econ_state_map.RData")
library(shiny)
library(shinydashboard)
library(htmlwidgets)
library(leaflet)
library(maps)
library(tidyverse)
library(RColorBrewer)
library(htmltools)
library(leaflet.extras)
library(magrittr)
getwd()
runApp('C:/Users/80921/OneDrive/桌面/course/5243 Applied Data Science/Project/Spring2020-Project2-group7/counties_map')
setwd('C:/Users/80921/OneDrive/桌面/course/5243 Applied Data Science/Project/Spring2020-Project2-group7/counties_map')
runApp()
Econ_data_state
Econ_state_map
Econ_data_state
Econ_data_state$name %>% unique()
Econ_data_state$Name %>% unique()
colnames(Econ_data_state)
load("../output/counties.RData")
counties
Econ_data_county = counties %>% pivot_wider(names_from = 'Metric', values_from = 'value')
Econ_data_county = counties %>% pivot_wider(names_from = 'Metric', values_from = 'Value')
Econ_data_county
Econ_data_state
Econ_data_county
Econ_data_county  = Econ_data_county %>% select(-FIPS)
Econ_data_county
Econ_data_state
Econ_data_county
?save
save(Econ_data_county, file = ../output/Econ_county_map")
)
""
save(Econ_data_county, file = "../output/Econ_county_map")
load("../output/Econ_scounty_map.RData")
getwd()
save(Econ_data_county, file = "../output/Econ_county_map.Rdata")
